# Generated by Django 5.2.8 on 2025-11-25 13:06

import time
from datetime import timedelta

from django.core.cache import cache
from django.db import migrations
from django.utils import timezone

from ureport.utils import chunk_list


def noop(apps, schema_editor):  # pragma: no cover
    pass


def backfill_poll_stats_counters(apps, schema_editor):  # pragma: no cover
    PollStats = apps.get_model("stats", "PollStats")

    GenderSegment = apps.get_model("stats", "GenderSegment")
    AgeSegment = apps.get_model("stats", "AgeSegment")
    SchemeSegment = apps.get_model("stats", "SchemeSegment")

    PollStatsCounter = apps.get_model("stats", "PollStatsCounter")
    PollEngagementDailyCount = apps.get_model("stats", "PollEngagementDailyCount")

    Poll = apps.get_model("polls", "Poll")
    PollQuestion = apps.get_model("polls", "PollQuestion")
    Boundary = apps.get_model("locations", "Boundary")
    STATE_LEVEL = 1
    DISTRICT_LEVEL = 2
    WARD_LEVEL = 3

    stopped_polls = Poll.objects.filter(stopped_syncing=True).values_list("id", flat=True)
    flow_result_ids = PollQuestion.objects.filter(poll_id__in=stopped_polls).values_list("flow_result_id", flat=True)

    last_backfilled_poll_stats_id_key = "migrations_backfilled_poll_stats_last_id"
    last_id = cache.get(last_backfilled_poll_stats_id_key, 0)

    poll_stat_ids = list(
        PollStats.objects.filter(flow_result_id__in=flow_result_ids, id__gt=last_id)
        .order_by("id")
        .values_list("id", flat=True)
    )
    total = len(poll_stat_ids)
    print(f"Total PollStats to migrate: {total}")
    start_time = time.time()

    gender_dict = {elt.id: elt.gender.lower() for elt in GenderSegment.objects.all()}
    age_dict = {elt.id: elt.min_age for elt in AgeSegment.objects.all()}
    scheme_dict = {elt.id: elt.scheme.lower() for elt in SchemeSegment.objects.all()}

    boundaries = Boundary.objects.all().select_related('parent__parent')
    location_dict = {elt.id: elt for elt in boundaries.iterator()}

    processed = 0
    for batch in chunk_list(poll_stat_ids, 1000):
        batch_ids = list(batch)
        stats = PollStats.objects.filter(id__in=batch_ids)

        poll_stats_counter_obj_to_insert = []
        poll_engagement_daily_count_obj_to_insert = []

        for stat in stats:
            stat_counter_kwargs = dict(
                org_id=stat.org_id,
                flow_result_id=stat.flow_result_id,
                flow_result_category_id=stat.flow_result_category_id,
                count=stat.count,
            )
            engagement_counter_kwargs = dict()
            if stat.date is not None and stat.date >= (timezone.now() - timedelta(days=400)):
                engagement_counter_kwargs = dict(
                    org_id=stat.org_id,
                    flow_result_id=stat.flow_result_id,
                    is_responded=bool(stat.flow_result_category_id),
                    day=stat.date.date(),
                    count=stat.count,
                )

            scopes = ["all"]
            if stat.age_segment_id and age_dict.get(stat.age_segment_id) is not None:
                scopes.append(f"age:{age_dict.get(stat.age_segment_id)}")
            if stat.gender_segment_id and gender_dict.get(stat.gender_segment_id) is not None:
                scopes.append(f"gender:{gender_dict.get(stat.gender_segment_id)}")
            if stat.scheme_segment_id and scheme_dict.get(stat.scheme_segment_id) is not None:
                scopes.append(f"scheme:{scheme_dict.get(stat.scheme_segment_id)}")
            if stat.location_id:
                location = location_dict.get(stat.location_id)
                if location:
                    if location.level == WARD_LEVEL:
                        scopes.append(f"ward:{location.osm_id.upper()}")
                        if location.parent:
                            scopes.append(f"district:{location.parent.osm_id.upper()}")
                        if location.parent and location.parent.parent:
                            scopes.append(f"state:{location.parent.parent.osm_id.upper()}")
                    if location.level == DISTRICT_LEVEL:
                        scopes.append(f"district:{location.osm_id.upper()}")
                        if location.parent:
                            scopes.append(f"state:{location.parent.osm_id.upper()}")
                    if location.level == STATE_LEVEL:
                        scopes.append(f"state:{location.osm_id.upper()}")

            for scope in scopes:
                poll_stats_counter_obj_to_insert.append(PollStatsCounter(**stat_counter_kwargs, scope=scope))
                if engagement_counter_kwargs:
                    poll_engagement_daily_count_obj_to_insert.append(
                        PollEngagementDailyCount(**engagement_counter_kwargs, scope=scope)
                    )

        PollStatsCounter.objects.bulk_create(poll_stats_counter_obj_to_insert, batch_size=1000)
        PollEngagementDailyCount.objects.bulk_create(poll_engagement_daily_count_obj_to_insert, batch_size=1000)

        cache.set(last_backfilled_poll_stats_id_key, batch_ids[-1], None)

        processed += len(batch_ids)
        elapsed = time.time() - start_time
        print(f"Backfilled {processed} of {total} PollStats in {elapsed:.1f} seconds")


def apply_manual():  # pragma: no cover
    from django.apps import apps

    backfill_poll_stats_counters(apps, None)


class Migration(migrations.Migration):

    dependencies = [
        ("stats", "0031_pollengagementdailycount_pollstatscounter"),
    ]

    operations = [migrations.RunPython(backfill_poll_stats_counters, noop)]
